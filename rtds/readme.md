# RTDS
Сервер для сбора производственных данных с уровня атоматизации в режиме реального времени.

## Источники данных
Сбор обеспечивается со следующий источников:
- PLC по протоколу Modbus TCP (MWP)
- Сревер OPC (в перспективе)
- Реляционные базы 

## Архитектура
Сервер состоит из нескольких программных компонентов:
- server.py основной скрипт запуска сервера
- storage.py модуль сохранения данных в локальный буфер
- models.py модель данных
- config.py модуль работы с конфигурацией
- connectors модуль коннекторов к раличным источникам
- scripts модуль поддержки запуска скриптов расчётов по расписанию
- config.ods файл с тестовой конфигрурацией

## Коннекторы
Для подключения к источнику данных используется коннектор. Каждый коннектор запускется 
в отдельном процессе через заданный интервал. 

Коннектор обеспечивает:
- подключение к источнику
- чтение данных по заданному адресу
- передачу данных в центральный процесс сервера
- получение данных от центрального процесса для записи
- запись данных в источник

Для конфигурирования коннетора используется строка вида:

```
# строка для modbus tcp
connector=имя класса; host=адрес; port=xxxx; unit_id=1; timeout=5; auto_open=true; auto_close=true
```
Каждый класс коннетора имеет свой набор параметров


## Скрипты
Скрипты используются для выполнения промежуточных расчётов по считанным данным и заполнения
новых тегов новыми значениями. Скрипты запускаются после выполнения операции чтения всеми коннекторами
и перед выполнением записи данных в конневторы для записи в источник.
Например скрипт может выполнять при пакетном считывания данных из регистров в массив и последующем распределении 
данных из массива по тегам.
Пример скрипта
```
import random as rnd
tgv = self.server.get('Tag_1') # чтение тега из памяти
print(tgv)
tgv.value = rnd.uniform(0,100)
tgv.status = 0
self.server.set(tgv) # сохранение тега в памяти
```

## Локальный буфер
Локальный буфер используется для временного хранения данных для обеспечения 
возможности сбора этих данных сервером Historian. Сам RTDS не передаёт данные
в Historian.
За работу локального буфера отвечает storage.py, а данные сохраняются в sqlite.
После того как Historian считал данные он передаёт обратно временную метку ниже которой данные могут быть удалены.

Для уменьшения объёма хранения данных используется удаление из буфера данных с одинаковыми значениями за периоды, что обеспечивает меньшее места для хранения.

Как вариант:

данные сохраняются в плоской таблице и каждый раз обновляются, если значение изменилось больше заданного отклонения, то делается копия в архивную таблицу, если нет изменений значений в течении заданного периода, то данные из таблицы копируются в архивную с текущей временной меткой.
